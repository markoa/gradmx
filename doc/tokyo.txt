Uvod
----

Tokyo Cabinet [*] je biblioteka za upravljanje bazom podataka. U njenoj implementaciji, baza podataka je jednostavna datoteka niza zapisa koji se sastoje od ključa i vrednosti (key-value). Svaki ključ i vrednost su niz bajtova promenljive dužine, te mogu biti kako niz karaktera, tako i binarni podaci. Ne postoji koncept tabela podataka ili tipova podataka. Zapisi su organizovani u heš tabeli, B+ stablu ili nizu fiksne dužine.

U okviru baze podataka zasnovanoj na heš tabeli, svaki ključ mora biti jedinstven. Za pristup bazi se pruža mogućnost snimanja zapisa sa ključem i vrednošću, kao i čitanja i brisanja zapisa po ključu. Postoji mogućnost prolaska kroz sve zapise, mada bez određenog redosleda. Ove metode pristupa su slične onima iz biblioteke DBM (ili njenim sledbenicima, kao na primer GDBM [*] [*]), definisanoj u UNIX standardu. Tokyo Cabinet predstavlja alternativu DBM-u pre svega zbog boljih performansi. Heš baza podataka je slična onoj kojom upravlja biblioteka BerkeleyDB [*].

U bazi podataka čija se implementacija zasniva na B+ stablu, zapisi mogu da imaju ključeve koji se ponavljaju. Metoda pristupa za snimanje, čitanje i brisanje su dostupne kao i u bazi heš tabele - funkcionalno, one su ekvivalentne. Međutim, njena interna struktura pruža mogućnost uređivanje ključeva po korisnički definisanoj funkciji. To omogućava upite po prefiksu ključa, preuzimanje niza vrednosti prema opsegu ključeva, kao i prolazak kroz sve zapise kursorom u željenom redosledu.

U bazi podataka u kojoj se podaci smeštaju u niz fiskne dužine, zapisi se čuvaju pod jedinstvenim prirodnim brojem, pa prema tome ne postoji trošak (overhead) ključa. Nije moguće snimiti dva ili više zapisa pod istim brojem. Dužina svakog zapisa je ograničena zadatom vrednošću. Dostupne su iste metode pristupa kao i kod heš baze podataka.

Postoji i tabelarna baza podataka (table database), koja je zasnovana na heš implementaciji. Svaki zapis je identifikovan primarnim ključem i ima skup proizvoljnih imenovanih kolona. Ne postoji pojam sheme podataka, ali je moguća pretraga zapisa pomoću kompleksnih upita, kao i postavljanje indeksa na kolone. Po svojim osobinama, tabelarna baza podataka je slična CouchDB [*].

Tokyo Cabinet je napisan u programskom jeziku C, a API postoji u jezicima C, Ruby, Perl, Python, Java i Lua. Biblioteka je dostupna na platformama koje podržavaju C99 i POSIX standarde, pod GNU Lesser General Public licencom.

U izradi projekta je korišćena Ruby biblioteka rufus-tokyo [*] za pristup Tokyo Cabinet bazama podataka. Ona je izabrana umesto Ruby biblioteke koja je dostupna na sajtu Tokyo Cabinet-a (tokyocabinet-ruby) zbog bolje dokumentacije, nešto intuitivnijeg API, kao i prenosivosti na Ruby platforme koje se izvršavaju u virtuelnim mašinama, kao što su JRuby [*] i Rubinius [*]. Naime, tokyocabinet-ruby delom sadrži C kod koji se kompajlira na mašini na kojoj se instalira, što je čini neupotrebljivom na pomenutim alternativnim Ruby platformama. Sa druge strane, rufus-tokyo se zasniva na biblioteci ruby-ffi [*], koja omogućava programsko učitavanje dinamičkih biblioteka, povezivanje sa njihovim funkcijama i njihovo pozivanje direktno iz Ruby koda. Napomenimo i da rufus-tokyo omogućava pozivanje funkcija iz kompajlirane biblioteke, ukoliko je ona prisutna u sistemu.

Heš baza podataka
-----------------

Tokyo Cabinet koristi heš algoritam za čitanje (retrieval) zapisa. Ukoliko bucket array!!! ima dovoljno elemenata, vremenska kompleksnost čitanja zapisa je O(1). Drugim rečima, vreme čitanja zapisa je konstantno, bez obzira na veličinu baze podataka. Isto je i sa snimanjem i brisanjem. Kolizija heš vrednosti se rukuje posebnim lančanjem. Struktura podataka lanaca je binarno stablo pretrage. Čak i ako su elementi bucket arraya neobično retki, vremenska kompleksnost čitanja je O(log n).

Tokyo Cabinet čitav bucket niz, koji je snimljen u datoteci, učitava u RAM, i to ne read() sistemskim pozivom već ga direktno mapira na memoriju sa mmap(). Zbog toga je vreme povezivanja sa bazom veoma kratko, a memorijska mapa je deljiva između dva i više procesa. Smatra se da je optimalna veličina bucket niza polovina broja zapisa u bazi podataka, što uzrokuje koliziju heš vrednosti u 56.7% slučajeva. U tim slučajevima, pristup željenom zapisu se odvija u dve ili manje operacija nad datotekom. Veličina svakog elementa bucket niza je 4 bajta. To znači da je sa 2MB RAM moguće upravljati bazom od 1 miliona zapisa.

Veličina datoteke može tokom rada značajno da se poveća usled fragmentacije regiona podataka. Tokyo Cabinet rešava ovaj problem sjedinjavanjem i ponovnim korišćenjem regiona koji su ostali van upotrebe. Na primer, ukoliko se na mesto jednog zapisa upisuje novi koji je duži, iskoristiće se sav region starog zapisa, a razlika će se upisati u slobodan prostor (padding) drugih. Takođe, prisutno je i pronalaženje slobodnog regiona koji najviše odgovara novom zapisu, kao i periodični proces defragmentacije koji radi nad većom grupom regiona, tako što im ili postepeno menja mesto u datoteci ili odjednom ponovo prepisuje sadržaj datoteke prethodno koristeći privremenu datoteku za preraspodelu.

Primer 1.1

B+ stablo baza podataka
-----------------------

Prednost B+ stablo baze podataka u odnosu na onu zasnovanu na heš tabeli jeste to što pruža mogućnost pristupa zapisi po određenom redosledu, po cenu brzine. Redosled se zadaje korisničkom funkcijom, i zapisi se sortiraju i uređuju u logičke stranice. Za svaku stranicu postoji retki indeks organizovan u B+ višesmerno stablo. Vremenska kompleksnost pribavljanja je O(log n), i ono se obavlja korišćenjem kursora, koji može da se pozicionira da bilo koju poziciju zadavanjem ključa i odatle pomera u oba smera. Pošto je svaka stranica uređena u dvostruko spregnutu listu, vremenska kompleksnot pomeranja kursora je O(1).

Svaka stranica B+ baze podataka se čuva kao zaseban zapis heš baze podataka, i time ona nasleđuje prostornu efikasnost. Pošto je zaglavlje svakog zapisa manje i poravnanje svake stranice podešeno prema veličini stranice, u najčešćem slučaju je veličina datoteke baze podataka za polovinu manja u odnosu na heš bazu. Iako su za ažuriranje B+ stabla potrebne operacije nad više stranica, Tokyo Cabinet ubrzava taj proces keširanjem stranica i smanjenjem broja neophodnih operacija nad datotekom. Pošto je najčešće ceo retki indeks keširan u memoriji, moguće je pribaviti zapis u jednoj datotečnoj operaciji.

Svako B+ stablo može da se snima kompresovano. Podržana su dva metoda kompresije: deflate (zlib) i block sorting (bzip2). Pošto je svaki zapis u stranici slične strukture, može se očekivati visok nivo kompresije zahvaljujući Lempel-Ziv ili BWT algoritmima. U slučaju tekstualnih podataka, veličina datoteke može da se smanji na oko 25%. Ukoliko je baza podataka obimna i usko operacije čitanja i pisanja na disku predstavljaju usko grlo, kompresija može značajno da poboljša performanse obrade.

Baza podataka fiksne dužine
---------------------------

Baza podataka fiksne dužine može da sadrži vrednosti ograničene dužine, sa ključevima koji moraju biti prirodni brojevi. Ova struktura podataka ima osobine veće vremenske i prostorne efikasnosti u odnosu na druge.

Ceo region baze podataka se mapira na memoriju 'mmap' pozivom i pristupa mu se kao višedimenzionalnom nizu, čime je smanjen broj operacija nad datotekom. Zahvaljujući ovoj jednostavnoj strukturi, baza fiksne dužine radi brže od heš baze podataka uz očuvanu konkurentnost u višenitnom okruženju.

Veličina baze podataka je proporcionalna rasponu ključeva i najvećoj dozvoljenoj dužini vrednosti. Što je raspon ključeva manji ili je manja dužina svake vrednosti, postiže se bolja prostorna efikasnost. Na primer, ukoliko je najveći ključ 1000000 i vrednost ograničena na 100 bajtova, veličina baze podataka će biti oko 100MB. Pošto se regioni oko zatraženih zapisa uvek nalaze u RAM-u, veličina baze se može povećati do veličine virtuelne memorije.

Primer 1.2

Tabelarna baza podataka
-----------------------

Tabelarna baza podataka ne izražava strukturu ključ-vrednost već onu poput tabele u relacionoj bazi podataka. Svaki zapis je identifikovan primarnim ključem i poseduje skup kolona proizvoljnog naziva. Na primer, ljudi zaposleni u jednoj firmi mogu da se izraze zapisima čiji je primarni ključ identifikacioni broj zaposlenog, strukturiranih po kolonama koje izražavaju njegovo ime, odsek, platu itd. Za razliku od relacionih baza podataka, tabelarna baza ne zahteva definisanje šeme podataka i može da sadrži zapisa međusobno različitih struktura.

Tabelarna baza podataka podržava upite ne samo po primarnom ključu već i po uslovima za proizvoljne kolone. Svaki takav uslov se sastoji od imena kolone podataka i uslovnog operatora. Za tekstualni (string) tip podataka, pružaju se uslovi potpunog podudaranja, podudaranja unapred (forward matching) i poređenja sa regularnim izrazima. Za podatke koji su brojevi, pružaju se operatori poput potpunog podudaranja i pronalaženja po opsegu. Postoje i operatori za pretragu po tagu i punog teksta (full-text search). Upit može da sadrži više uslova koji formiraju logički presek, a omogućeno je i sortiranje rezultata u rastućem ili opadajućem redosledu za tekstualne i brojčane podatke.

Moguće je definisati indekse nad kolonama u cilju poboljšanja performansi pretrage i sortiranja. Iako kolone nemaju tipove podataka, indeksi mogu biti tekstualnog ili brojčanog tipa. Podržani su i obrnuti indeksi (inverted index) za simbole odvojene praznim mestom i N-gram karakterne simbole. Indeksi služe optimizatoru upita koji priprema svaki upit. Indeksi su implementirani kao B+ baze podataka snimljene u zasebne datoteke.

Primer 1.3

Praktična funkcionalnost
------------------------

Sve Tokyo Cabinet baze podataka podržavaju mehanizam transakcije. Moguće je združeno izvršiti niz operacija između početka i kraja transakcije, ili prekinuti transakciju i izvršiti povratak na stanje pre njenog početka.

Tokyo Cabinet pruža dva načina priključivanja na bazu podataka: čitajući i pišući. Čitač može da pribavlja ali ne i snima ili briše podatke. Pisaču su dozvoljene sve metode pristupa. Kontrola isključivosti procesa se vrši prilikom priključenja na bazu podataka pomoću zaključivanja datoteke. Dok je jedan pisač priključen na bazu, onemogućen je pristup drugim čitačima i pisačima. Dok je čitač priključen, omogućen je pristup drugim čitačima, ali ne i pisačima.

API funkcije su konkurentne (reentrant) i dostupne u višenitnom okruženju. Za kontrolu pristupa operacija nad istim objektima baza podataka koriste se read-write locks. Dok jedna pišuća nit radi nad bazom, druge čitajuće i pišuće niti se blokiraju. Međutim, dok čitajuća nit pristupa bazi, drugim čitajućim nitima je pristup dozvoljen. Heš i niz baze podataka se zaključavaju po zapisu, a druge po datoteci.

Pristupni interfejs
-------------------

Tokyo Cabinet pruža jednostavan objektno orijentisan API. Svaka operacija nad bazom podataka ima odgovarajuću metodu, na primer 'open' (priključivanje), 'close' (prekid rada), 'put' (umetanje), 'out' (brisanje), 'get' (pribavljanje) itd. Heš, B+ i niz baze podataka imaju veoma sličan API, pa je migracija koda sa jednog tipa baze na drugi jednostavna. Sem toga, postoji i mogućnost korišćenja apstraktnog API-a koji nudi uniforman pristup svim tipovima baze podataka. Aplikacije koje koriste apstraktni API mogu da odrede tip baze u vreme izvršavanja koda.

Postoji i pomoćni API. On definiše osnovne strukture podataka kao što su lista i mapa, implementaciju memorijskog bazena (memory pool), kao i pomoćne metode za rad sa stringovima.

Šest vrsta API-a postoje za programski jezik C: pomoćni, API za rad sa heš, B+ stablo, niz, tabela bazama podataka, kao i apstraktni. Postoji i interfejs za komandnu liniju koji odgovara svakom od navedenih, namenjen za izradu prototipova, testiranje i debagovanje. Sem za C, API je dostupan i u jezicima Ruby, Perl, Java i Lua.

Tokyo Tyrant
------------

Tokyo Tyrant predstavlja paket koji služi kao mrežni interfejs za konkurentni pristup Tokyo Cabinet bazama podataka. Koristi se u slučajevima kada je potrebno da više procesa pristupa istoj bazi, ili da se pristupi bazi koja se nalazi na udaljenom računaru. Paket se sastoji od servera - procesa koji upravlja bazom podataka i pristupne biblioteke za klijentske aplikacije.

Server svoju konkurentnost zasniva na implementaciji modeliranoj prema thread pool-u i epoll/kqueue mehanizmu dostupnom u modernim Linux i BSD kernelima. Server i klijent komuniciraju kroz jednostavan binarni protokol zasnovanom na TCP/IP. Takođe implementira HTTP i memcached protokole tako da je dostupan za klijentske aplikacije na večini platformi, pisanih u različitim programskim jezicima. Za integritet podataka služe mehanizmi backup, update logging i replikacije. Server može da u svoj proces ugradi skript jezik Lua, pomoću koga je moguće definisati dodatne operacije nad bazom podataka.

Server koristi apstraktni API, čime podržava sve tipove Tokyo Cabinet baza podataka, uključujući i memorijske heš i B+ stablo baze, kao i posebne odlike tabelarne baze podatake kroz odgovarajuća proširenja. Server radi na Linux, FreeBSD, Max OS X i Solaris operativnim sistemima.

Korišćenje Tiranina
-------------------

Program `ttserver' pokreće server koji upravlja instancom baze podataka. Tip baze se može odabrati u vreme pokretanja servera pošto on bazi pristupa pomoću apsktraktnog API-a Tokyo Cabinet-a, i on se određuje na osnovu ekstenzije zadatog naziva datoteke. Konvencija imenovanja različitih tipova baza je sledeća:

 - "*"    - označava memorijski heš
 - "+"    - memorijsko stablo
 - ".tch" - heš baza podataka
 - ".tcb" - B+ b.p.
 - ".tcf" - b.p. fiksne dužine
 - ".tct" - tabelarna b.p.

Pored samog tipa, moguće je zadati režim pristupa kao i neki od parametara podešavanja (tuning) baze podataka, kao što su tip kompresije podataka i broj elemenata bucket niza. Neki od ovih parametara će biti posebno spomenuti kasnije u tekstu.

Primer pokretanja servera za tabelarnu bazu podataka na portu 1985:

[terminal-1]$ ttserver -port 1985 page_views.tct

Tyrant paket sadrži još dva serverska programa:

 - `ttservctl' služi za pokretanje i kontrolu servera. Namenjen je za korišćenje u korisničkim skriptovima i umetanje u boot sekvencu operativnog sistema.

 - `ttulmgr' je namenjen za uvoz i izvoz zapisnika ažuriranja (update log). Korisno je po potrebi filtrirati ovaj zapisnik pomoću alata kao što je `grep'.

Tokyo Tyrant paket sadrži i nekoliko klijentskih programa:

 - `tcrtest' je namenjen za testiranje performansi sistema. Pomoću njega je na primer moguće zadati komande poput pisanja i uklanjanja podataka na serveru na određenom portu u određenom broju iteracija.

 - `tcrmttest' je namenjen za testiranje performansi sistema u konkurentnom okruženju.

 - `tcrmgr' je namenjem testiranju i debagovanju udaljenog API-a i njegovih aplikacija. Pomoću njega je moguće pristupati bazi podataka na način na koji to omogućava Tyrant API.

Kompletno uputstvo za upotrebu ovih programa se nalazi na web stranici specifikacije Tokyo Tyrant.

Sledi kratak primer koda za pristup bazi pomoću Tokyo Tyrant.

Primer 1.4

Backup i oporavak podataka
--------------------------

Naredni primer pokazuje kako se sa klijentske strane može zatražiti backup podataka u novu datoteku baze.

Pokrenimo jednu instancu servera koja rukuje heš bazom podataka:

[terminal-1]$ ttserver kutija.tch

Sačuvajmo nekoliko zapisa pomoću klijentskog programa tcrmgr u drugom prozoru sistemskog terminala.

[terminal-2]$ tcrmgr put localhost jedan prvi
[terminal-2]$ tcrmgr put localhost dva drugi
[terminal-2]$ tcrmgr put localhost tri treci

Komandom `tcrmgr copy' pravimo backup datoteku na zadatom serveru. Treba primetiti da se backup datoteka pravi na lokalnom sistemu datoteka servera, a ne na klijentskoj strani.

[terminal-2]$ tcrmgr copy localhost backup.tch

Ugasimo server sa Ctrl-C i uklonimo datoteku baze podataka.

[terminal-1]$ rm kutija.tch

Povratimo bazu podataka iz backup datoteke i ponovo pokrenimo server.

[terminal-1]$ cp backup.tch kutija.tch
[terminal-1]$ ttserver kutija.tch

Proverimo konzistentnost podataka.

[terminal-2]$ tcrmgr mget localhost jedan dva tri
jedan	prvi
dva	drugi
tri	treci

Update log
----------

Update log, ili zapisnik ažuriranja, je druga mera kojom Tokyo Tyrant omogućava čuvanje konzistentnosti podataka. Na zahtev, on se vodi kao zasebna datoteka u zadatom direktorijumu tokom rada servera. Na osnovu te datoteke je moguće dobiti sadržaj originalne baze podataka.

U narednom primeru ćemo pokrenuti jednu instancu servera sa uključenim zapisnikom ažuriranja. Uz opciju `-ulog' se zadaje direktorijum za smeštanje datoteka zapisnika.

[terminal-1]$ mkdir ulog
[terminal-1]$ ttserver -ulog ulog -sid 1 kutija.tch

Snimimo nekoliko zapisa.

[terminal-2]$ tcrmgr put localhost jedan prvi
[terminal-2]$ tcrmgr put localhost dva drugi
[terminal-2]$ tcrmgr put localhost tri treci

Ugasimo server sa Ctrl-C i uklonimo datoteku baze podataka.

[terminal-1]$ rm kutija.tch

Iskopirajmo direktorijum zapisnik i pokrenimo novu instancu servera.

[terminal-1]$ mv ulog ulog-back
[terminal-1]$ mkdir ulog
[terminal-1]$ ttserver -ulog ulog -sid 1 kutija.tch

Povratimo bazu podataka iz zapisnika ažuriranja, koristeći komandu `tcrmgr restore'.

[terminal-2]$ tcrmgr restore localhost ulog-back

Proverimo konzistentnost podataka.

[terminal-2]$ tcrmgr mget localhost jedan dva tri
jedan	prvi
dva	drugi
tri	treci

Replikacija
-----------

Replikacija je mehanizam za sinhronizaciju dva ili više servera baza podataka u cilju postizanje visoke dostupnosti i integriteta podataka. Server koji je izvor replikacije se naziva vodećim (master), i svaki odredišni server se naziva pratećim (slave). Za replikaciju su neophodni sledeći uslovi:

 - Vodeći mora da vodi zapisnik ažuriranja.
 - Vodeći mora da specificira jedinstveni ID servera.
 - Svaki prateći mora da vodi zapisnik ažuriranja jer u slučaju pada vodećeg on može preuzeti njegovu ulogu.
 - Svaki prateći mora da navede jedinstveni ID servera jer u slučaju pada vodećeg on može preuzeti njegovu ulogu.
 - Svaki prateći mora da navede mrežnu adresu i port vodećeg servera.
 - Svaki prateći mora da navede datoteku vremenskog pečata replikacije (replication timestamp file).

Naredni primer pokazuje kako podesiti replikaciju između jednog vodećeg servera na portu 1984 i jednog pratećeg na portu 1985.

Prvo pokrenimo vodeći server.

[terminal-1]$ mkdir ulog-1
[terminal-1]$ ttserver -port 1984 -ulog ulog-1 -sid 1 kutija-1.tch

Potom pokrenimo prateći server.

[terminal-2]$ mkdir ulog-2
[terminal-2]$ ttserver -port 1985 -ulog ulog-2 -sid 2 \
                -mhost localhost -mport 1984 -rts 2.rts kutija-2.tch

Snimimo nekoliko zapisa u vodeći.

[terminal-3]$ tcrmgr put -port 1984 localhost jedan prvi
[terminal-3]$ tcrmgr put -port 1984 localhost dva drugi
[terminal-3]$ tcrmgr put -port 1984 localhost tri treci

Proverimo konzistentnost snimljenih zapisa u vodećem i pratećem.

[terminal-2]$ tcrmgr mget -port 1984 localhost jedan dva tri
[terminal-2]$ tcrmgr mget -port 1985 localhost jedan dva tri

Simulirajmo slučaj da je došlo do pada vodećeg servera. Prekinimo njegov rad sa Ctrl-C i uklonimo njegovu datoteku baze podataka.

[terminal-1]$ rm kutija-1.tch

Prekinimo rad pratećeg i pokrenimo ga kao vodećeg.

[terminal-2]$ ttserver -port 1985 -ulog ulog-2 -sid 2 kutija-2.tch

I novi prateći, na portu 1986.

[terminal-1]$ mkdir ulog-3
[terminal-1]$ ttserver -port 1986 -ulog ulog-3 -sid 3 \
                -mhost localhost -mport 1985 -rts 3.rts kutija-3.tch

Snimimo novi zapis u vodeći.

[terminal-2]$ tcrmgr put -port 1985 localhost cetiri cetvrti

Proverimo konzistentnost podataka u novom vodećem i novom pratećem serveru.

[terminal-2]$ tcrmgr mget -port 1985 localhost jedan dva tri cetiri
[terminal-2]$ tcrmgr mget -port 1986 localhost jedan dva tri cetiri

Tokyo Tyrant podržava i "dual master" replikaciju koja omogućava još viši nivo dostupnosti podataka. Ostvaruje se pokretanjem dva servera koji replikuju jedan drugog. Pri tome treba voditi računa da će pisanje na oba servera dovesti do do njihove međusobne nekonzistentnosti. Serveri će u tom slučaju nastaviti sa radom; postoji opcija `-rss' sa kojom će dolaziti do provera i prestanka replikacije u slučaju nekonzistentnosti podataka.

Tuning
------

Prilikom pokretanja instanci Tokyo Tyrant servera, moguće je navesti niz parametara za podešavanje rada.

U radu koji uključuje snimanje zapisa u datoteku, moguće je odabrati neku od opcija za kompresiju podataka. Dostupni algoritmi su Deflate, BZIP2 i TCBS. Korišćenje kompresije utiče na brzinu rada.

Ukoliko se koristi heš baza podataka, preporučljivo je iskoristiti "#bnum=xxx" parametar radi poboljšanja performansi. bnum broj određuje bucket broj i trebao bi da bude veći od očekivanog broja zapisa.

U slučaju B+ stable baze, preporučuje se podešavanje parametara "#lcnum=xxx#bnum=yyy". Prvi određuje maksimalni broj listova u stablu koji se mogu keširati. Trebao bi da bude što veći, onoliko koliko količina sistemskog RAM-a dozvoljava. Drugi određuje bucket broj i trebao bi da bude veći od 1/128 od broja zapisa koji se očekuju.

Ukoliko se očekuje da serveru pristupa veliki broj klijenata, treba osloboditi ograničenje broja deskriptora datoteka po procesu. Na većini sistema on iznosi 1024. Može se poništiti opcijom "ulimit".

Da bi se rešili problemi dostupnosti koji mogu nastati naglom pojavom velikog broja upita na bazu, preporučuje se sistem koji uključuje replikaciju između memorijske i datotečne baze podataka. U toj postavci, vodeći server bi bio memorijski, a prateći bi ostvarivao trajnost podataka.

Benchmark i rezultati
---------------------

http://tokyocabinet.sourceforge.net/
http://www.gnu.org/software/gdbm/
http://www.vivtek.com/gdbm/
http://www.oracle.com/technology/products/berkeley-db/db/index.html
http://couchdb.apache.org/
http://rufus.rubyforge.org/
http://jruby.codehaus.org/
http://rubini.us/
http://kenai.com/projects/ruby-ffi
