Programski jezik Ruby
=====================

Za razumevanje Rails frameworka i praćenja koda koji je izložen u ovom radu potrebno je poznavati Ruby, programski jezik u kome je napisan. Pošto na srpskom jeziku postoji vrlo malo literature o njemu, u ovom poglavlju će biti izložen pregled osnovnih, a potom i neki od naprednijih elemenata jezika koji su osnova Rails frameworka.

Ruby je dinamički interpretirani programski jezik. Inspirisan je jezicima Lisp, Smalltalk i Perl, ali mu je gramatika lako razumljiva C i Java programerima. Ruby je potpuno objektno orijentisani jezik, ali je takođe prigodan i za proceduralni i funkcionalni stil programiranja. Pruža mogućnosti metaprogramiranja koje mogu da se koriste u svrhu stvaranja jezika specifičnog domena (domain-specific languages, DSL).

Objektna orijentisanost
-----------------------

U Rubiju, svaka vrednost je objekat, čak i prosti numerički simboli i vrednosti true, false i nil (nil je Ruby varijanta null - posebna vrednost koja označava odsustvo vrednosti). Drugim rečima ne postoji pojam primitivnih i objektnih tipova. U primerima koji to demonstriraju pozivamo metodu po imenu class. Komentari u Rubiju počinju sa #.

  1.class      # => Fixnum
  0.0.class    # => Float
  true.class   # => TrueClass: true je singlton instanca od TrueClass
  false.class  # => FalseClass
  nil.class    # => NilClass

Koriščenje zagrada prilikom pozivanja funkcija i metoda nije neophodno. U Rubiju su zagrade obično opcione i često se ni ne pišu, naročito kada se pozvanoj metodi ne prosleđuje nijedan parametar. Posledica toga je da poziv metode liči na referenciranje imenovanog polja ili promenljive objekta. To nije slučajno, međutim Ruby striktno vodi računa o enkapsulaciji; pristup unutrašnjem stanju objekta spolja nije dozvoljen. Svakom takvom pristupu mora posredovati pristupna metoda, kao što je metoda class u primeru iznad.

Kontrola toka
-------------

Ruby sadrži uobičajene kontrole toka, kao što su naredba if ili while petlja. Razlikuje se od jezika iz C familije po tome što se ne koriste vitičaste zagrade oko tela ovih naredbi, već kraj tela označava ključna reč end:

if count > 10
  puts "Pokušajte ponovo"
elsif count == 3
  puts "Trojka"
else
  puts "Unesite broj"
end

while weight < 400 and people_count <= 10
  person = next_person()
  weight += person.weight
  people_count += 1
end

Modifikatori naredbi su korisni kada je telo naredbe ili petlje samo jedan izraz:

puts "Paran broj broj" unless x%2 == 1
distance = distance * 1.2 while distance < 100

Metode
------

Metode se definišu pomoću ključne reči def. Rezultat izvršavanja je uvek rezultat poslednje linije koda u njoj. Stoga se pisanje ključne reči return često izostavlja:

def square(x)
  x*x
end

Blokovi i iteratori
-------------------

Petlje se često pišu pomoću posebnih metoda koje se nazivaju iteratori.

3.times { puts "gradmx" }   # ispis će se ponoviti tri puta
[1, 2, 3].each { |i| puts } # ispis svakog od elementa niza
selected = [1, 2, 3, 4].select { |i| i%2 == 0 } # izdvoj elemente deljive sa 2
selected.inject do |sum, i| # izračunaj sumu elemenata => 6
  sum + x
end

times, each, select i inject su iteratori koji interakuju sa blokovima koda koji dolaze posle njih. Kontrola toka koja stoji iza ovoga je yield, naredba koja privremeno prebacuje kontrolu izvršavanja sa iteratora na blok koji je vezan za poziv iteratora. Kada dođe do kraja koda u bloku, metoda iteratora preuzima kontrolu i nastavlja sa izvršenjem od prve linije posle ključne reči yield. Česta konvencija je da se jednolinijski blokovi pišu sa vitičastim zagradama, a blokovi sa više linija koda sa do/end. Naredni primer definiše metodu koja prima blok:

# Generiše sekvencu od n brojeva m*i + c i prosleđuje ih bloku.
def sequence(n, m, c)
  i = 0
  while(i < n)
    yield i*m + c    # bloku prosledi naredni element sekvence
    i += 1
  end
end

sequence(5, 2, 2) { |x| puts x } # Ispisuje brojeve 2, 4, 6, 8, 10

Povezivanje bloka koda sa pozivom metode je osnovna i vrlo važna mogućnost Rubija. Ono ne mora biti vezano samo za petlje, na primer:

File.open("data.txt") do |f|
  line = f.readline
end

Jedna od osobina blokova je njihova anonimnost. Ne prosleđuju se metodama u uobičajenom smislu, nemaju ime i pozivaju se upotrebom ključne reči a ne metodom. Ukoliko je potrebna veća kontrola nad blokom (na primer, u slučaju da ga je potrebno proslediti drugoj metodi), dodaje se poslednji argument u nizu sa prefiksom &. Taj argument će se tada odnositi na blok, ukoliko se prosledi. Vrednost argumenta će biti objekat klase Proc, a umesto korišćenja yield, poziva se pomoću metode call:

def sequence2(n, m, c, &b) # Eksplicitan argument za blok kao Proc
  i = 0
  while(i < n)
    b.call(i*m + c)        # Poziv Proc-a njegovom metodom call
    i += 1
  end
end

# Blok se i dalje prosleđuje na isti način
sequence2(5, 2, 2) { |x| puts x }

Proc i lambda
-------------

U Rubiju je dakle moguće definisati objekat koji predstavlja blok koda, što predstavlja osnovu funkcionalnog programiranja. U zavisnosti od toga na koji način se objekat kreira, on se naziva proc ili lambda. Proc se ponaša slično bloku, dok se lamda ponaša kao metoda. Oboje su međutim instance klase Proc.

U prethodnom primeru je već prikazan jedan način stvaranja Proc objekta: povezivanjem bloka sa metodom koja je definisana sa argumentom za blok. Takva metoda je slobodna da recimo vrati Proc objekat. Sledeći kratak primer definiše metodu koja implicitnom konverzijom pravi proc na osnovu bloka:

def makeproc(&p)
  p
end

Sa makeproc je dalje moguće napraviti Proc objekat:

adder = makeproc { |x,y| x+y }

Promenljiva adder je sada referenca na Proc objekat vrste proc. Pomoću njegove metode call može se pozvati blok koda koji sadrži:

sum = adder.call(2,2) # => 4

Isti objekat se mogao dobiti i korišćenjem new metode:

adder = Proc.new { |x,y| x+y }

Druga tehnika kreiranja Proc objekata je pomoću metode lambda. lambda je metoda Kernel modula, pa deluje kao globalna funkcija. Proc objekat koji vraća je vrste lambda a ne proc. lambda ne očekuje da joj se proslede argumenti, ali njen poziv mora biti praćen blokom:

is_positive = lambda { |x| x > 0 }

lambda i proc se razlikuju u nekoliko pojedinosti, a najvažnije se tiču ponašanja naredbe return i načina na koji tretiraju prosleđene argumente.

U slučaju proc, na naredbu return se neće vratiti samo kod iz bloka već i metoda koja ga sadrži. Kod lambdi međutim, koje se ponašaju više kao metode, vraća se samo iz same lambde. Ova osobina čini lambdu praktičnijom u slučajevima kompleksnijih blokova.

proc prihvata argumente u fleksibilnoj yield semantici koja toleriše različitost u broju lvrednosti i drvrednosti (vrednosti sa leve, odnosno desne strane operatora dodele), dok se lambda drži stroge semantike metoda.

p = Proc.new { |x,y| print x,y }
p.call(1)       # x,y=1:     nil se koristi za dvrednost koja nedostaje: ispisuje 1nil
p.call(1,2)     # x,y=1,2:   2 lvrednosti, 2 dvrednosti:    ispisuje 12
p.call(1,2,3)   # x,y=1,2,3: dodatna dvrednost se ignoriše: ispisuje 12
p.call([1,2])   # x,y=[1,2]: niz se automatski otpakovao:   ispisuje 12

Lambde se međutim moraju pozivati sa tačno onoliko argumenata sa koliko su definisane:

l = lambda { |x,y| print x,y }
l.call(1,2)     # Radi
l.call(1)       # Pogrešan broj argumenata
l.call(1,2,3)   # Pogrešan broj argumenata
l.call([1,2])   # Pogrešan broj argumenata
l.call(*[1,2])  # Radi, eksplicitno otpakivanje niza

Heševi i simboli
----------------

Heševi su, kao i nizovi, osnovna struktura podataka u Rubiju. Zasnovani su na strukturi podataka heš tabele i služe za mapiranje proizvoljnih ključeva na (takođe proizvoljne) vrednosti.

h = {
  :jedan => 1,
  :dva => 2
}
h[:jedan]                   # => 1
h[:tri] = 3                 # dodaje nov par u heš

h.each do |key, value|      # ugrađeni iterator each daje ključ i vrednost
  print "#{key}: #{value}"  # primer interpolacije stringova;
                            # implicitno je pozvana metoda to_s,
                            # koju poseduje svaki objekat
end

Heševi se često koriste kao parametri funkcija. U Rubiju je pisanje vitičastih zagrada opciono ukoliko je heš poslednji u listi parametara. Rails ovu mogućnost često koristi, a rezultat je intuitivniji i izražajniji kod. U sledećoj liniji se prosleđuje jedan heš funkciji redirect_to. Zbog izostavljanja zagrada utisak je da Rails ima definisane posebne ključne ruči za ovu svrhu.

redirect_to :action => 'show', :id => event.id

Heševi mogu da prime bilo koji objekat kao ključ, međutim za to se, kao u primeru iznad, najčešće koriste simboli. Simboli su nepromenljivi, interno čuvani stringovi. Tipična implementacija Ruby interpretera sadrži tabelu simbola u kojoj se čuvaju imena svih klasa, metoda i promenljivih za koje se zna. Ovo omogućava interpreteru da izbegne većinu poređenja stringova, tako što će, na primer, pronalaziti imena metoda po njihovoj poziciji u tabeli simbola. To pretvara relativno skupu string operaciju u jeftinu integer operaciju.

Simboli se mogu koristiti u reflektivnom kodu kao referenca na naziv metode. Naredni kod proverava da li objekat o sadrži metodu zadatu metodu (size) i poziva je u slučaju da da:

name = :size
if o.respond_to? name
  o.send(name)
end

Imena, prefiksi i sufiksi
-------------------------

Lokalne promenljive, parametri metoda i nazivi metoda treba da počnu malim slovom ili donjom crtom: event, user_name. Promenljive instanci (podaci članovi) počinju znakom @, na primer @location. Klasne promenljive (class variables, deljene među svim instancama jedne klasa) počinju sa @@, a globalne promenljive sa $. Ruby konvencija je da se koristi donja crta za razdvajanje reči u nazivima promenljivih ili metoda.

Imena klasa, modula i konstanti moraju početi velikim slovom. Po konvenciji reči se u njima razdvajaju velikim slovima, npr. ActiveRecord.

Ruby metode mogu da se završe i znakom jednakosti, upitnikom i uzvičnikom. Metode koje se završavaju znakom jednakosti mogu da se pozivaju sintaksom dodele. Ukoliko objekat o ima metodu x=, onda su sledeće dve linije koda ekvivalentne:

o.x=(1) # Uobičajena sintaksa pozivanja metode
o.x = 1 # Pozivanje metoda kroz dodelu

Upitnik označava predikat - metode koje vraćaju Boolean vrednost. Na primer, klase Array i Hash definišu metodu empty? koja proverava da li struktura sadrži ijedan element. Uzvičnik na kraju naziva metode ukazuje da ona koristi sa opreznošću. Niz klasa iz standardne Ruby biblioteke definiše parove metoda koje se isto zovu, osim što se jedna završava uzvičnikom. Obično se radi o tome da jedna vraća modifikovanu kopiju izvornog objekta, dok druga vrši operaciju nad samim objektom. Tako Array objekti imaju metode sort i sort!. U Railsu je češće razlika u (ne)bacanju izuzetka, npr. save i save!.

Izuzeci
-------

Izuzeci su objekti klase Exception ili neke od njenih podklasa. Metoda raise baca zadati izuzetak, nakon čega se tok izvršenja koda prekida i Ruby vrši pretragu unazad po steku za kodom koji može da rukuje izuzetkom.

Izuzecima se rukuje stavljanjem koda između ključnih reči begin i end i korišćenjem rescue za presretanje određenih klasa izuzetaka:

begin
  content = load_blog_data(file_name)
rescue BlogDataNotFound
  STDERR.puts "Ne pronalazim datoteku #{file_name}"
rescue BlogDataFormatError
  STDERR.puts "Neispravni podaci u #{file_name}"
rescue Exception => exc
  STDERR.puts "Opšta greška prilikom čitanja #{file_name}: #{exc.message}"
end

Metoda raise klase Kernel baca izuzetak. Inače, metode koje definiše Kernel su globalne funkcije, kao i svaka korisnička funkcija koja se definiše van tela bilo koje klase. Korisničke globalne funkcije se definišu kao privatne metode klase Object.

Naredne tri linije su ekvivalentni primeri bacanja izuzetka:

raise ArgumentError, "loš argument" if n < 1
raise ArgumentError.new("loš argument") if n < 1
raise ArgumentError.exception("loš argument") if n < 1

Klase
-----

Klasa je skup srodnih metoda koje vrše operacije nad stanjem jednog objekta. Stanje objekta je određeno njegovim podacima članovima: promenljivima čija imena počinju sa @ i čije su vrednosti specične za dati objekat.

Sledi primer definicije klase:

class Order < ActiveRecord::Base

  has_many :line_items

  def self.all_unpaid
    all('paid = 0')
  end

  def total
    sum = 0
    line_items.each { |li| sum += li.total }
  end
end

Klasa Order je definisana kao podklasa klase Base u ActiveRecord modulu.

U Railsu su česte upotrebe deklaracija na nivou klase. U ovom primeru has_many je metoda koju definiše ActiveRecord. Poziva se u trenutku definisanja klase Order. Obično iza upotrebe ovakvog tipa metoda stoji nekoliko pretpostavki o klasi koja je poziva, pa se zato često nazivaju deklaracijama.

Unutar tela klase mogu se definisati klasne metode i metode instanci. Klasne metode bi se u jezicima C++ i Java nazivale statičkim metodama klase, a metode instanci funkcijama članicama. Prefiks self. metodu čini klasnom, kao što je slučaj sa metodom all_unpaid u primeru iznad. Ona se može pozvati bilo gde u aplikaciji na sledeći način:

unpaid_orders = Order.all_unpaid

Obične definicije metoda stvaraju metode instanci, kao što je funkcija total. One se pozivaju nad objektima klase, na primer:

puts "Ukupna suma je #{order.total}"

Promenljive instanci nisu dostupne van klase. Za to je potrebno definisati pristupne metode:

class Person

  def initialize(name)
    @name = name
  end

  def name
    @name
  end

  def name=(new_name)
    @name = new_nam
  end
end

p = Person.new("Milutin")
puts p.name               # => Milutin
p.name = "Milica"
puts p.name               # => Milica

Ruby sadrži metoda koje predstavljaju prečicu za pisanje pristupnih metoda.

class Person
  attr_acessor :name  # stvara metode očitavanja i dodele
  attr_reader  :age   # stvara samo metodu očitavanja
  attr_writer  :note  # stvara samo metodu dodele
end

Moduli
------

Moduli su slični klasama po tome što takođe sadrže skup metoda, konstanti i definicije drugih modula i klasa. Za razliku od klasa, na osnovu modula nije moguće napraviti objekat.

Moduli imaju dve svrhe. Prva je da se ponašaju kao prostor imena, omogućavajući definisanje metoda čija imena neće biti u koliziji sa istoimenim metodama definisanim u drugim delovima aplikacije. Drugo, omogućavaju deobu funkcionalnosti među klasama. Takvi moduli se često nazivaju mixin. Ukoliko se klasa pomeša sa modulom, metode definisane u modulu će biti dosupne kao metode instance te klase. Više klasa može da se pomeša sa istim modulom, deleći njegovo ponašanje bez koriščenja nasleđivanja. Takođe je moguće pomešati više modula u jednu klasu.

Enumerable je poznat primer mixin modula. Enumerable definiše niz korisnih iteratora koji se zasnivaju na iteratoru each, koju sam modul ne definiše. Klasa koja definiše metodu each i pomeša se sa modulom Enumerable dobiće na raspolaganje niz drugih metoda kao što su collect, find, select i sort. Za mešanje modula sa klasom koristi se metoda include, što u praksi liči na ključnu reč:

class Archive
  include Enumerable
end

Reference objekata
------------------

Rad sa objektima u Rubiju je zapravo rad sa referencama na objekte. Ruby nema pokazivače. Reference su dostupne jedino implementaciji samog jezika. Nema načina da se dobije adresa neke vrednosti, dereferencira vrednost ili vrše aritmetičke operacije nad pokazivačima. Kada dodeljujemo vrednost promenljivoj mi zapravo smeštamo referencu na objekat u tu promenljivu. To ilustruje sledeći primer:

s = "Ruby" # Napravi objekat tipa String. Sačuvaj referencu na njega u s.
t = s      # Iskopiraj referencu u t. s i t se sada odnose na isti objekat.
t[-1] = "" # Modifikuj objekat kroz referencu t.
print s    # Pristupi modifikovanom objektu preko s. Ispisuje "Rub".
t = "Java" # t se sada odnosi na drugi objekat.
print s,t  # Ispisuje "RubJava".

Metodama se takođe prosleđuju reference objekata. Može se reći da se parametri metoda prosleđuju po vrednosti, ali da su te vrednosti reference. To za posledicu ima da metode mogu preko dobijenih referenci da modifikuju objekte, što će biti vidljivo kada metoda završi sa izvršavanjem.

Životni vek objekata
--------------------

Objekti klasa se najčešće stvaraju metodom new:

obj = Person.new

new je metoda klase Class. Ona alocira memoriju potrebnu za čuvanje novog objekta, potom inicijalizuje stanje praznog objekta pozivajući njegovu metodu initialize. Većina klasa definiše svoju initialize metodu, koja odgovara pojmu konstruktora iz jezika C++ ili Java. Klasa naravno može po potrebi da definiše i dodatne factory (klasne) metode.

Ruby objekti ne moraju da se eksplicitno oslobađaju iz memorije, kao što je to slučaj u jezicima C i C++. Ruby koristi tehniku garbage collection koja automatski uništava objekte koji više nisu potrebni. Objekat postaje kandidat za uklanjanje iz memorije je nedostupan, tj. kada nema nijedne preostale reference na taj objekat osim iz drugih nedostupnih objekata.
