Programski jezik Ruby
=====================

Za razumevanje Rails frameworka i praćenja koda koji je izložen u ovom radu potrebno je poznavati Ruby, programski jezik u kome je napisan. Pošto na srpskom jeziku postoji vrlo malo literature o njemu, u ovom poglavlju će biti izložen pregled osnovnih, a potom i neki od naprednijih elemenata jezika koji su osnova Rails frameworka.

Ruby je dinamički interpretirani programski jezik. Inspirisan je jezicima Lisp, Smalltalk i Perl, ali mu je gramatika lako razumljiva C i Java programerima. Ruby je potpuno objektno orijentisani jezik, ali je takođe prigodan i za proceduralni i funkcionalni stil programiranja. Pruža mogućnosti metaprogramiranja koje mogu da se koriste u svrhu stvaranja jezika specifičnog domena (domain-specific languages, DSL).

Objektna orijentisanost
-----------------------

U Rubiju, svaka vrednost je objekat, čak i prosti numerički simboli i vrednosti true, false i nil (nil je Ruby varijanta null - posebna vrednost koja označava odsustvo vrednosti). Drugim rečima ne postoji pojam primitivnih i objektnih tipova. U primerima koji to demonstriraju pozivamo metodu po imenu class. Komentari u Rubiju počinju sa #.

  1.class      # => Fixnum
  0.0.class    # => Float
  true.class   # => TrueClass: true je singlton instanca od TrueClass
  false.class  # => FalseClass
  nil.class    # => NilClass

Koriščenje zagrada prilikom pozivanja funkcija i metoda nije neophodno. U Rubiju su zagrade obično opcione i često se ni ne pišu, naročito kada se pozvanoj metodi ne prosleđuje nijedan parametar. Posledica toga je da poziv metode liči na referenciranje imenovanog polja ili promenljive objekta. To nije slučajno, međutim Ruby striktno vodi računa o enkapsulaciji; pristup unutrašnjem stanju objekta spolja nije dozvoljen. Svakom takvom pristupu mora posredovati pristupna metoda, kao što je metoda class u primeru iznad.

Kontrola toka
-------------

Ruby sadrži uobičajene kontrole toka, kao što su naredba if ili while petlja. Razlikuje se od jezika iz C familije po tome što se ne koriste vitičaste zagrade oko tela ovih naredbi, već kraj tela označava ključna reč end:

if count > 10
  puts "Pokušajte ponovo"
elsif count == 3
  puts "Trojka"
else
  puts "Unesite broj"
end

while weight < 400 and people_count <= 10
  person = next_person()
  weight += person.weight
  people_count += 1
end

Modifikatori naredbi su korisni kada je telo naredbe ili petlje samo jedan izraz:

puts "Paran broj broj" unless x%2 == 1
distance = distance * 1.2 while distance < 100

Metode
------

Metode se definišu pomoću ključne reči def. Rezultat izvršavanja je uvek rezultat poslednje linije koda u njoj. Stoga se pisanje ključne reči return često izostavlja:

def square(x)
  x*x
end

Blokovi i iteratori
-------------------

Petlje se često pišu pomoću posebnih metoda koje se nazivaju iteratori.

3.times { puts "gradmx" }   # ispis će se ponoviti tri puta
[1, 2, 3].each { |i| puts } # ispis svakog od elementa niza
selected = [1, 2, 3, 4].select { |i| i%2 == 0 } # izdvoj elemente deljive sa 2
selected.inject do |sum, i| # izračunaj sumu elemenata => 6
  sum + x
end

times, each, select i inject su iteratori koji interakuju sa blokovima koda koji dolaze posle njih. Kontrola toka koja stoji iza ovoga je yield, naredba koja privremeno prebacuje kontrolu izvršavanja sa iteratora na blok koji je vezan za poziv iteratora. Kada dođe do kraja koda u bloku, metoda iteratora preuzima kontrolu i nastavlja sa izvršenjem od prve linije posle ključne reči yield. Česta konvencija je da se jednolinijski blokovi pišu sa vitičastim zagradama, a blokovi sa više linija koda sa do/end. Naredni primer definiše metodu koja prima blok:

# Generiše sekvencu od n brojeva m*i + c i prosleđuje ih bloku.
def sequence(n, m, c)
  i = 0
  while(i < n)
    yield i*m + c    # bloku prosledi naredni element sekvence
    i += 1
  end
end

sequence(5, 2, 2) { |x| puts x } # Ispisuje brojeve 2, 4, 6, 8, 10

Povezivanje bloka koda sa pozivom metode je osnovna i vrlo važna mogućnost Rubija. Ono ne mora biti vezano samo za petlje, na primer:

File.open("data.txt") do |f|
  line = f.readline
end

Jedna od osobina blokova je njihova anonimnost. Ne prosleđuju se metodama u uobičajenom smislu, nemaju ime i pozivaju se upotrebom ključne reči a ne metodom. Ukoliko je potrebna veća kontrola nad blokom (na primer, u slučaju da ga je potrebno proslediti drugoj metodi), dodaje se poslednji argument u nizu sa prefiksom &. Taj argument će se tada odnositi na blok, ukoliko se prosledi. Vrednost argumenta će biti objekat klase Proc, a umesto korišćenja yield, poziva se pomoću metode call:

def sequence2(n, m, c, &b) # Eksplicitan argument za blok kao Proc
  i = 0
  while(i < n)
    b.call(i*m + c)        # Poziv Proc-a njegovom metodom call
    i += 1
  end
end

# Blok se i dalje prosleđuje na isti način
sequence2(5, 2, 2) { |x| puts x }

Proc i lambda
-------------

U Rubiju je dakle moguće definisati objekat koji predstavlja blok koda, što predstavlja osnovu funkcionalnog programiranja. U zavisnosti od toga na koji način se objekat kreira, on se naziva proc ili lambda. Proc se ponaša slično bloku, dok se lamda ponaša kao metoda. Oboje su međutim instance klase Proc.

U prethodnom primeru je već prikazan jedan način stvaranja Proc objekta: povezivanjem bloka sa metodom koja je definisana sa argumentom za blok. Takva metoda je slobodna da recimo vrati Proc objekat. Sledeći kratak primer definiše metodu koja implicitnom konverzijom pravi proc na osnovu bloka:

def makeproc(&p)
  p
end

Sa makeproc je dalje moguće napraviti Proc objekat:

adder = makeproc { |x,y| x+y }

Promenljiva adder je sada referenca na Proc objekat vrste proc. Pomoću njegove metode call može se pozvati blok koda koji sadrži:

sum = adder.call(2,2) # => 4

Isti objekat se mogao dobiti i korišćenjem new metode:

adder = Proc.new { |x,y| x+y }

Druga tehnika kreiranja Proc objekata je pomoću metode lambda. lambda je metoda Kernel modula, pa deluje kao globalna funkcija. Proc objekat koji vraća je vrste lambda a ne proc. lambda ne očekuje da joj se proslede argumenti, ali njen poziv mora biti praćen blokom:

is_positive = lambda { |x| x > 0 }

lambda i proc se razlikuju u nekoliko pojedinosti, a najvažnije se tiču ponašanja naredbe return i načina na koji tretiraju prosleđene argumente.

U slučaju proc, na naredbu return se neće vratiti samo kod iz bloka već i metoda koja ga sadrži. Kod lambdi međutim, koje se ponašaju više kao metode, vraća se samo iz same lambde. Ova osobina čini lambdu praktičnijom u slučajevima kompleksnijih blokova.

proc prihvata argumente u fleksibilnoj yield semantici koja toleriše različitost u broju lvrednosti i drvrednosti (vrednosti sa leve, odnosno desne strane operatora dodele), dok se lambda drži stroge semantike metoda.

p = Proc.new { |x,y| print x,y }
p.call(1)       # x,y=1:     nil se koristi za dvrednost koja nedostaje: ispisuje 1nil
p.call(1,2)     # x,y=1,2:   2 lvrednosti, 2 dvrednosti:    ispisuje 12
p.call(1,2,3)   # x,y=1,2,3: dodatna dvrednost se ignoriše: ispisuje 12
p.call([1,2])   # x,y=[1,2]: niz se automatski otpakovao:   ispisuje 12

Lambde se međutim moraju pozivati sa tačno onoliko argumenata sa koliko su definisane:

l = lambda { |x,y| print x,y }
l.call(1,2)     # Radi
l.call(1)       # Pogrešan broj argumenata
l.call(1,2,3)   # Pogrešan broj argumenata
l.call([1,2])   # Pogrešan broj argumenata
l.call(*[1,2])  # Radi, eksplicitno otpakivanje niza

Heševi i simboli
----------------

Heševi su, kao i nizovi, osnovna struktura podataka u Rubiju. Zasnovani su na strukturi podataka heš tabele i služe za mapiranje proizvoljnih ključeva na (takođe proizvoljne) vrednosti.

h = {
  :jedan => 1,
  :dva => 2
}
h[:jedan]                   # => 1
h[:tri] = 3                 # dodaje nov par u heš

h.each do |key, value|      # ugrađeni iterator each daje ključ i vrednost
  print "#{key}: #{value}"  # primer interpolacije stringova;
                            # implicitno je pozvana metoda to_s,
                            # koju poseduje svaki objekat
end

Heševi se često koriste kao parametri funkcija. U Rubiju je pisanje vitičastih zagrada opciono ukoliko je heš poslednji u listi parametara. Rails ovu mogućnost često koristi, a rezultat je intuitivniji i izražajniji kod. U sledećoj liniji se prosleđuje jedan heš funkciji redirect_to. Zbog izostavljanja zagrada utisak je da Rails ima definisane posebne ključne ruči za ovu svrhu.

redirect_to :action => 'show', :id => event.id

Heševi mogu da prime bilo koji objekat kao ključ, međutim za to se, kao u primeru iznad, najčešće koriste simboli. Simboli su nepromenljivi, interno čuvani stringovi. Tipična implementacija Ruby interpretera sadrži tabelu simbola u kojoj se čuvaju imena svih klasa, metoda i promenljivih za koje se zna. Ovo omogućava interpreteru da izbegne većinu poređenja stringova, tako što će, na primer, pronalaziti imena metoda po njihovoj poziciji u tabeli simbola. To pretvara relativno skupu string operaciju u jeftinu integer operaciju.

Simboli se mogu koristiti u reflektivnom kodu kao referenca na naziv metode. Naredni kod proverava da li objekat o sadrži metodu zadatu metodu (size) i poziva je u slučaju da da:

name = :size
if o.respond_to? name
  o.send(name)
end

Imena, prefiksi i sufiksi
-------------------------

Lokalne promenljive, parametri metoda i nazivi metoda treba da počnu malim slovom ili donjom crtom: event, user_name. Promenljive instanci (podaci članovi) počinju znakom @, na primer @location. Klasne promenljive (class variables, deljene među svim instancama jedne klasa) počinju sa @@, a globalne promenljive sa $. Ruby konvencija je da se koristi donja crta za razdvajanje reči u nazivima promenljivih ili metoda.

Imena klasa, modula i konstanti moraju početi velikim slovom. Po konvenciji reči se u njima razdvajaju velikim slovima, npr. ActiveRecord.

Ruby metode mogu da se završe i znakom jednakosti, upitnikom i uzvičnikom. Metode koje se završavaju znakom jednakosti mogu da se pozivaju sintaksom dodele. Ukoliko objekat o ima metodu x=, onda su sledeće dve linije koda ekvivalentne:

o.x=(1) # Uobičajena sintaksa pozivanja metode
o.x = 1 # Pozivanje metoda kroz dodelu

Upitnik označava predikat - metode koje vraćaju Boolean vrednost. Na primer, klase Array i Hash definišu metodu empty? koja proverava da li struktura sadrži ijedan element. Uzvičnik na kraju naziva metode ukazuje da ona koristi sa opreznošću. Niz klasa iz standardne Ruby biblioteke definiše parove metoda koje se isto zovu, osim što se jedna završava uzvičnikom. Obično se radi o tome da jedna vraća modifikovanu kopiju izvornog objekta, dok druga vrši operaciju nad samim objektom. Tako Array objekti imaju metode sort i sort!. U Railsu je češće razlika u (ne)bacanju izuzetka, npr. save i save!.

Izuzeci
-------

Izuzeci su objekti klase Exception ili neke od njenih podklasa. Metoda raise baca zadati izuzetak, nakon čega se tok izvršenja koda prekida i Ruby vrši pretragu unazad po steku za kodom koji može da rukuje izuzetkom.

Izuzecima se rukuje stavljanjem koda između ključnih reči begin i end i korišćenjem rescue za presretanje određenih klasa izuzetaka:

begin
  content = load_blog_data(file_name)
rescue BlogDataNotFound
  STDERR.puts "Ne pronalazim datoteku #{file_name}"
rescue BlogDataFormatError
  STDERR.puts "Neispravni podaci u #{file_name}"
rescue Exception => exc
  STDERR.puts "Opšta greška prilikom čitanja #{file_name}: #{exc.message}"
end

Metoda raise klase Kernel baca izuzetak. Inače, metode koje definiše Kernel su globalne funkcije, kao i svaka korisnička funkcija koja se definiše van tela bilo koje klase. Korisničke globalne funkcije se definišu kao privatne metode klase Object.

Naredne tri linije su ekvivalentni primeri bacanja izuzetka:

raise ArgumentError, "loš argument" if n < 1
raise ArgumentError.new("loš argument") if n < 1
raise ArgumentError.exception("loš argument") if n < 1

Klase
-----

Klasa je skup srodnih metoda koje vrše operacije nad stanjem jednog objekta. Stanje objekta je određeno njegovim podacima članovima: promenljivima čija imena počinju sa @ i čije su vrednosti specične za dati objekat.

Sledi primer definicije klase:

class Order < ActiveRecord::Base

  has_many :line_items

  def self.all_unpaid
    all('paid = 0')
  end

  def total
    sum = 0
    line_items.each { |li| sum += li.total }
  end
end

Klasa Order je definisana kao podklasa klase Base u ActiveRecord modulu.

U Railsu su česte upotrebe deklaracija na nivou klase. U ovom primeru has_many je metoda koju definiše ActiveRecord. Poziva se u trenutku definisanja klase Order. Obično iza upotrebe ovakvog tipa metoda stoji nekoliko pretpostavki o klasi koja je poziva, pa se zato često nazivaju deklaracijama.

Unutar tela klase mogu se definisati klasne metode i metode instanci. Klasne metode bi se u jezicima C++ i Java nazivale statičkim metodama klase, a metode instanci funkcijama članicama. Prefiks self. metodu čini klasnom, kao što je slučaj sa metodom all_unpaid u primeru iznad. Ona se može pozvati bilo gde u aplikaciji na sledeći način:

unpaid_orders = Order.all_unpaid

Obične definicije metoda stvaraju metode instanci, kao što je funkcija total. One se pozivaju nad objektima klase, na primer:

puts "Ukupna suma je #{order.total}"

Promenljive instanci nisu dostupne van klase. Za to je potrebno definisati pristupne metode:

class Person

  def initialize(name)
    @name = name
  end

  def name
    @name
  end

  def name=(new_name)
    @name = new_nam
  end
end

p = Person.new("Milutin")
puts p.name               # => Milutin
p.name = "Milica"
puts p.name               # => Milica

Ruby sadrži metode koje predstavljaju prečicu za pisanje pristupnih metoda.

class Person
  attr_accessor :name  # stvara metode očitavanja i dodele, kao u kodu iznad
  attr_reader  :age   # stvara samo metodu očitavanja
  attr_writer  :note  # stvara samo metodu dodele
end

p = Person.new
p.name = "Zlatan"
puts p.name       # => Zlatan

attr_accessor, attr_reader i attr_writer su metode definisane u klasi Module. Sve klase su moduli (klasa Class je podklasa klase Module), tako da se ove metode mogu koristiti unutar definicije bilo koje klase.

Pomoću ključne reči self se može doći do instance trenutnog objekta u datom kontekstu koda:

class Person
  # ...
  self.name = "Ime"
end

Moduli
------

Moduli su slični klasama po tome što takođe sadrže skup metoda, konstanti i definicije drugih modula i klasa. Za razliku od klasa, na osnovu modula nije moguće napraviti objekat.

Moduli imaju dve svrhe. Prva je da se ponašaju kao prostor imena, omogućavajući definisanje metoda čija imena neće biti u koliziji sa istoimenim metodama definisanim u drugim delovima aplikacije. Drugo, omogućavaju deobu funkcionalnosti među klasama. Takvi moduli se često nazivaju mixin. Ukoliko se klasa pomeša sa modulom, metode definisane u modulu će biti dosupne kao metode instance te klase. Više klasa može da se pomeša sa istim modulom, deleći njegovo ponašanje bez koriščenja nasleđivanja. Takođe je moguće pomešati više modula u jednu klasu.

Enumerable je poznat primer mixin modula. Enumerable definiše niz korisnih iteratora koji se zasnivaju na iteratoru each, koju sam modul ne definiše. Klasa koja definiše metodu each i pomeša se sa modulom Enumerable dobiće na raspolaganje niz drugih metoda kao što su collect, find, select i sort. Za mešanje modula sa klasom koristi se metoda include, što u praksi liči na ključnu reč:

class Archive
  include Enumerable
end

Ovakvo korišćenje modula pruža prednosti koje proizilaze iz višestrukog nasleđivanja poznatog iz jezika C++, ali održava odnose među klasama u jednostavnoj strukturi stabla i značajno olakšava implementaciju.

Reference objekata
------------------

Rad sa objektima u Rubiju je zapravo rad sa referencama na objekte. Ruby nema pokazivače. Reference su dostupne jedino implementaciji samog jezika. Nema načina da se dobije adresa neke vrednosti, dereferencira vrednost ili vrše aritmetičke operacije nad pokazivačima. Kada dodeljujemo vrednost promenljivoj mi zapravo smeštamo referencu na objekat u tu promenljivu. To ilustruje sledeći primer:

s = "Ruby" # Napravi objekat tipa String. Sačuvaj referencu na njega u s.
t = s      # Iskopiraj referencu u t. s i t se sada odnose na isti objekat.
t[-1] = "" # Modifikuj objekat kroz referencu t.
print s    # Pristupi modifikovanom objektu preko s. Ispisuje "Rub".
t = "Java" # t se sada odnosi na drugi objekat.
print s,t  # Ispisuje "RubJava".

Metodama se takođe prosleđuju reference objekata. Može se reći da se parametri metoda prosleđuju po vrednosti, ali da su te vrednosti reference. To za posledicu ima da metode mogu preko dobijenih referenci da modifikuju objekte, što će biti vidljivo kada metoda završi sa izvršavanjem.

Životni vek objekata
--------------------

Objekti klasa se najčešće stvaraju metodom new:

obj = Person.new

new je metoda klase Class. Ona alocira memoriju potrebnu za čuvanje novog objekta, potom inicijalizuje stanje praznog objekta pozivajući njegovu metodu initialize. Većina klasa definiše svoju initialize metodu, koja odgovara pojmu konstruktora iz jezika C++ ili Java. Klasa naravno može po potrebi da definiše i dodatne factory (klasne) metode.

Ruby objekti ne moraju da se eksplicitno oslobađaju iz memorije, kao što je to slučaj u jezicima C i C++. Ruby koristi tehniku garbage collection koja automatski uništava objekte koji više nisu potrebni. Objekat postaje kandidat za uklanjanje iz memorije je nedostupan, tj. kada nema nijedne preostale reference na taj objekat osim iz drugih nedostupnih objekata.

Metaprogramiranje
-----------------

Refleksija, ili introspekcija, u osnovi prosto znači da program u vreme izvršavanja može da odredi svoje stanje i strukturu. Ruby program može, na primer, da dobije listu svih metoda klase Hash. Ruby API za refleksiju omogućava da program takođe i modifikuje svoje stanje i strukturu. Tako Ruby program može da dinamički postavlja vrednosti imenovanih promenljivih, poziva, menja i presreće pozive metoda, definiše nove klase i metode, manipuliše lancem nasleđivanja. Rubijev API za refleksiju, zajedno sa osobinama jezika kao što su njegova dinamička priroda, strukture blokova i iteratora i opcione zagrade, čine osnovu za metaprogramiranje.

Metaprogramiranje je tehnika programiranja kojom se piše kod koji piše drugi kod ili se samoispituje (introspekcija). Metaprogramiranje je tesno povezano sa idejom stvaranja jezika specifičnih domena (DSL). DSL-ovi u Rubiju obično koriste pozive metoda i blokove kao da se radi o ključnim rečima proširenja jezika za određenu namenu. U narednim odeljcima će biti prikazane neke od tehnika metaprogramiranja u Rubiju.

Evaluacija stringova
--------------------

Ruby program može da generiše string validnog Ruby koda i izvrši ga koristeći Kernel.eval:

x = 1
eval "x+1"  # => 2

Ova mogućnost je istovremeno i moćna i potencijalno opasna, ukoliko se izvršava kod koji zavisi od korisničkog unosa.

Upiti i postavljanje promenljivih
---------------------------------

Ruby definiše niz metoda za pravljenje upita i postavljanje promenljivih, kako instance tako i klase.

o = Object.new
o.instance_variable_set(:@x, 0) # prefix @ je obavezan
o.instance_variable_get(:@x)    # => 0
o.instance_variable_defined?(:@x) # => true

Object.class_variable_set(:@@x, 1)
Object.class_variable_get(:@@x)

Math.const_set(:EPI, Math::E*Math::PI)
Math.const_get(:EPI)             # => 8.53973422267357
Math.const_defined? :EPI         # => true

Definisanje metoda pomoću instance_eval i class_eval
----------------------------------------------------

Klasa Object definiše metodu instance_eval, a klasa Module definiše metodu class_eval. Obe ove funkcije izvršavaju (evaluate) Ruby kod kao što to radi eval, ali postoje dve značajne razlike. Prva je da one izvršavaju kod u kontekstu datog objekta ili modula - vrednost self je objekat ili modul u kome se kod izvršava. Evo primera:

o.instance_eval("@x")  # Vraća vrednost podatka člana @x objekta o

# Definiše metod instance len klase String koga vraća njegovu dužinu
String.class_eval("def len; size; end")

# Definiše klasnu metodu String.empty
String.instance_eval("def empty; ''; end")

puts String.new("text").len  # => 4
puts String.empty            # => ""

Druga bitna razlika između ove dve metode i globalne eval jeste to što instance_eval i class_eval mogu da prime blok koda za evaluaciju. Kada im se prosledi blok umesto stringa, kod u bloku se izvršava u odgovarajućem kontekstu. Sledi primer ekvivalentan prethodnom:

o.instance_eval { @x }

String.class_eval do
  def len
    size
  end
end

String.instance_eval { def empty; ""; end }

Klasna metoda se može definisati i sa class_eval koristeći sintaksu definisanja klasnih metoda:

String.class_eval { def self.empty; ""; end }

Naredni konkretniji primer pokazuje implementaciju metoda readonly i readwrite koje su ekvivalentne ranije opisanim metodama attr_reader i attr_accessor. One se definišu kao metode instanci klase Module, što ih čini metodama instanci klase Class. Kako je svaka klasa, tj. konstanta koja se piše velikim slovom i određuje je, objekat klase Class, to će metode readonly i readwrite biti klasne metode svake dalje definisane korisničke klase. Implementacija samih metoda se oslanja na class_eval i string konstrukciju tela metoda.

class Module
  private
  def readonly(*syms)
    return if syms.size == 0
    code = ""
    # Generiši string Ruby koda koji definiše metodu očitavanja atributa.
    # Primetimo kako se simbol interpolira u string koda.
    syms.each do |s|
      code << "def #{s}; @#{s}; end\n"
    end
    # class_eval-uiraj generisani kod i napravi metodu instance.
    class_eval code
  end

  def readwrite(*syms)
    return if syms.size == 0
    code = ""
    syms.each do |s|
      code << "def #{s}; @#{s} end\n"
      code << "def #{s}=(value); @#{s} = value; end\n"
    end
    class_eval code
  end
end

class Person
  readwrite :name, :age
end

p = Person.new
p.name = "Joanna"
puts p.name        # => Joanna

Definisanje metoda pomoću define_method
---------------------------------------

Drugi način dinamičkog kreiranja metoda jeste pomoću define_method. Ova funkcija se razlikuje od class_eval i instance_eval po tome što kao jedini parametar očekuje heš. Kao primer prikazaćemo implementaciju metode attributes koja ima istu ulogu kao readwrite, ali nešto drugačiju sintaksu korišćenja. Ključevi heša će označavati simbole atributa, a opcione vrednosti njihove početne vrednosti. Pošto vitičaste zagrade heša ne moraju da se pišu u slučaju da je heš poslednji argument u nizu, upotreba ove funkcije može izgledati ovako:

class Point
  attributes :x => 0, :y => 0
end

Ovo je još jedan primer korišćenja fleksibilne sintakse Rubija za kreiranje lako čitljivih metoda koje liče na ključne reči jezika. U Railsu su metode ovog tipa veoma česte, poput metoda asocijacije (has_many, belongs_to) i validacije (validates_presence_of).

class Module
  def attributes(hash)
    hash.each_pair do |symbol, default|
      getter = symbol                     # Ime metode očitavanja
      setter = :"#{symbol}="              # Ime metoda pisanja
      variable = :"@#{symbol}"            # Ime podatka člana

      define_method getter do             # Definiši metodu očitavanja
        if instance_variable_defined? variable
          instance_variable_get variable  # Vrati promenljivu, ukoliko je definisana
        else
          default                         # U suprotnom vrati početnu vrednost
        end
      end

      define_method setter do |value|     # Definiši metodu pisanja
        instance_variable_set variable,   # Postavi vrednost podatka člana
                              value       # Na vrednost prosleđenu u vreme izvršavanja
      end
    end
  end
  
  private :attributes
end

Lančanje metoda
---------------

Pored dinamičkog kreiranja metoda, Ruby nudi i dinamičku modifikaciju metoda. Metode se modifikuju tehnikom koja se naziva lančanje metoda (alias chaining, method chaining). Postupak je sledeći. Prvo se napravi se alias metode koja želi da se modifikuje. alias pruža ime koje se odnosi na nemodifikovanu verziju metode. Potom se kreira nova verzija metode, koja bi trebalo da pozove originalnu njenim aliasom, ali je slobodna da doda proizvoljnu funkcionalnost pre i nakon što to učini.

class TippingPoint < Point

  alias original_x, x

  def x
    original_x * 100
  end
end

Rukovanje nedefinisanim metodama
--------------------------------

Kada algoritam rezolucije imena metode ne uspe da pronađe pozvanu metodu, on traži metodu po imenu method_missing. Po pozivu ove metode, prvi argument je simbol koji imenuje metodu koja prethodno nije pronađena. Taj simbol prati niz argumenata koji su prosleđeni u izvornom pozivu, uključujući i eventualni blok.

Ugrađena implementacija metode method_missing u Kernel modulu jednostavno baca izuzetak NoMethodError. Ovaj izuzetak, ukoliko se ne uhvati, uzrokuje kraj programa uz poruku o grešci, kao što se i očekuje u slučaju poziva metode koja ne postoji.

Definisanje sopstvene metode method_missing pruža mogućnost rukovanja bilo kojom vrstom poziva koji se upućuju instancama klase. method_missing je jedna od najčešće korišćenih tehnika metaprogramiranja u Rubiju. Kompletan primer će biti prikazan kasnije u opisu implementacije aplikacije gradmx.

U Railsu se method_missing koristi, na primer, za generisanje dinamičkih upitnih funkcija. Na primer, ukoliko imamo klasu Person sa atributom name, Rails pruža na raspolaganje klasnu metodu find_by_name, čiji je prvi argument traženo ime, a ostali opcioni kao u slučaju opšte metode find:

recent_joannas = Person.find_by_name("joanna", :conditions => ["created_at < ?", 2.weeks.ago])

Ova metoda naravno nigde nije unapred definisana, već postoji implementacija method_missing koja, ukoliko prepozna format metode prihvatljiv po konvenciji, dinamički stvara klasnu metodu koja odgovara atributu koji se pominje u nazivu metode. To takođe znači da se ove metode kreiraju samo jedanput, i to tek na zahtev.
